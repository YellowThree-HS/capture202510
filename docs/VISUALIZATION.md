# 可视化功能说明

## 概述

系统提供多种可视化方式，帮助理解检测和位姿估计的结果。

## 1. 合并可视化（检测 + 分割）

### 功能描述

在一张图像上同时显示：
- **检测框**：标记物体的位置范围
- **分割掩码**：精确显示物体的形状（半透明叠加）
- **标签信息**：类别名称和置信度

### 示例输出

```
合并可视化文件: ./result/combined_20251011_163045.jpg
```

### 可视化元素

#### 1. 半透明分割掩码
- **透明度**：40%（可以看到原始图像）
- **作用**：精确显示物体的实际形状和边界
- **优点**：比矩形框更准确

#### 2. 检测框
- **样式**：彩色矩形边框
- **线条粗细**：2像素
- **颜色**：与掩码颜色一致

#### 3. 标签信息
- **位置**：检测框左上角
- **内容**：`类别名 置信度`
- **背景**：彩色填充（与检测框同色）
- **文字颜色**：白色
- **字体**：`cv2.FONT_HERSHEY_SIMPLEX`
- **示例**：
  ```
  cup 0.85
  spoon 0.78
  bowl 0.65
  ```

### 颜色方案

系统为不同物体分配不同颜色（BGR格式）：

| 索引 | 颜色名 | BGR值 | 适用 |
|------|--------|-------|------|
| 0 | 蓝色 | (255, 0, 0) | 第1个物体 |
| 1 | 绿色 | (0, 255, 0) | 第2个物体 |
| 2 | 红色 | (0, 0, 255) | 第3个物体 |
| 3 | 青色 | (255, 255, 0) | 第4个物体 |
| 4 | 紫色 | (255, 0, 255) | 第5个物体 |
| 5 | 黄色 | (0, 255, 255) | 第6个物体 |
| 6 | 粉色 | (128, 0, 255) | 第7个物体 |
| 7 | 橙色 | (0, 128, 255) | 第8个物体 |

如果物体超过8个，颜色会循环使用。

### 文件命名

- **格式**：`combined_YYYYMMDD_HHMMSS.jpg`
- **位置**：`./result/` 目录
- **示例**：`combined_20251011_163045.jpg`

### 自动显示

检测完成后，系统会：
1. 自动弹出窗口显示合并图像
2. 窗口标题：`Detection + Segmentation`
3. 按任意键关闭窗口

## 2. 3D可视化（位姿）

### 功能描述

使用Open3D显示：
- 完整场景点云
- 物体位姿坐标系
- 勺子的勺头中心标记（橙色球体）

### 触发方式

按 **v键** 打开3D可视化窗口

### 可视化内容

#### 点云
- **颜色**：保持原始RGB颜色
- **内容**：整个场景的3D点云

#### 物体坐标系
- **X轴**：红色（指向物体的右方）
- **Y轴**：绿色（对于勺子，指向勺头方向）
- **Z轴**：蓝色（对于碗，指向上方）
- **大小**：不同物体使用不同大小（0.08-0.14m）

#### 勺子特殊标记
- **橙色球体**：标记勺头中心位置
- **半径**：实际勺头半径的50%
- **颜色**：`[1.0, 0.5, 0.0]` (RGB)

### 操作方式

在Open3D窗口中：
- **鼠标左键拖动**：旋转视角
- **鼠标滚轮**：缩放
- **鼠标右键拖动**：平移
- **ESC键**：关闭窗口

## 3. 实时预览窗口

### 功能描述

显示相机的实时画面，用于调整位置和光照。

### 窗口信息

- **标题**：`D435 Camera - Real-time`
- **内容**：实时RGB图像
- **提示文字**：操作说明（左上角）

### 操作提示

窗口上显示：
```
SPACE: Detect | V: Visualize | Q: Quit
```

## 4. 检测结果窗口（旧版）

系统仍会生成单独的检测结果图像：

### 文件信息
- **文件名**：`det_frame_YYYYMMDD_HHMMSS.jpg`
- **位置**：`./result/` 目录
- **内容**：只显示检测框和标签（不含分割掩码）

注：建议使用**合并可视化**，信息更全面。

## 输出文件汇总

每次检测会生成以下文件：

| 文件 | 格式 | 内容 | 推荐使用 |
|------|------|------|---------|
| `det_frame_*.jpg` | 图像 | 检测框 + 标签 | ⭐ 仅查看检测框 |
| `seg_frame_*.jpg` | 图像 | 分割掩码（单个） | ⭐ 查看单个掩码 |
| `combined_*.jpg` | 图像 | 检测 + 分割合并 | ⭐⭐⭐ **最推荐** |

## 可视化示例场景

### 场景1：检测单个杯子

```
合并图像显示：
- 蓝色半透明填充（杯子形状）
- 蓝色矩形框
- 标签："cup 0.85"
```

### 场景2：检测多个碗

```
合并图像显示：
- 碗1：蓝色半透明 + 框 + "bowl 0.65"
- 碗2：绿色半透明 + 框 + "bowl 0.52"  
- 碗3：红色半透明 + 框 + "bowl 0.35"
```

### 场景3：检测杯子+勺子+碗

```
合并图像显示：
- 杯子：蓝色
- 勺子：绿色
- 碗：红色

3D可视化显示：
- 场景点云（白色）
- 3个物体坐标系
- 勺头橙色球体
```

## 技术细节

### 图像叠加算法

```python
# 半透明叠加公式
overlay = cv2.addWeighted(overlay, 1, colored_mask, 0.4, 0)
```

参数说明：
- `overlay`：原始图像
- `colored_mask`：彩色掩码
- `0.4`：掩码透明度（40%）
- `1`：原图权重（100%）

### 掩码处理

```python
# 创建彩色掩码
colored_mask = np.zeros_like(img)
colored_mask[mask > 0] = color

# 如果尺寸不匹配，调整大小
mask = cv2.resize(mask, (img.shape[1], img.shape[0]))
```

### 标签绘制

```python
# 1. 计算文字尺寸
(text_width, text_height), baseline = cv2.getTextSize(label, ...)

# 2. 绘制背景框
cv2.rectangle(overlay, (x1, y1-h), (x1+w, y1), color, -1)

# 3. 绘制白色文字
cv2.putText(overlay, label, (x1, y1), ..., (255,255,255))
```

## 自定义可视化

### 修改透明度

在 `lib/yolo_and_sam.py` 中修改：

```python
# 当前：40% 透明度
overlay = cv2.addWeighted(overlay, 1, colored_mask, 0.4, 0)

# 修改为 60% 透明度（掩码更明显）
overlay = cv2.addWeighted(overlay, 1, colored_mask, 0.6, 0)
```

### 修改检测框粗细

```python
# 当前：2像素
cv2.rectangle(overlay, (x1, y1), (x2, y2), color, 2)

# 修改为 3像素（更粗）
cv2.rectangle(overlay, (x1, y1), (x2, y2), color, 3)
```

### 修改字体大小

```python
# 当前
font_scale = 0.6
thickness = 2

# 改为更大的字体
font_scale = 0.8
thickness = 2
```

## 常见问题

### Q: 为什么掩码和检测框不完全对齐？

A: 这是正常的。检测框是矩形近似，而掩码是物体的精确轮廓。掩码会更准确。

### Q: 可以只显示掩码不显示检测框吗？

A: 可以，在 `_create_combined_visualization()` 函数中注释掉绘制检测框的代码：

```python
# cv2.rectangle(overlay, (x1, y1), (x2, y2), color, 2)
```

### Q: 颜色太相似，能改吗？

A: 可以修改 `colors` 列表，使用更对比的颜色：

```python
colors = [
    (255, 0, 0),      # 纯蓝
    (0, 255, 0),      # 纯绿
    (0, 0, 255),      # 纯红
    (255, 128, 0),    # 橙蓝
    (128, 0, 255),    # 粉红
    (0, 255, 255),    # 黄色
]
```

### Q: 如何保存3D可视化？

A: 在Open3D窗口中按 `Ctrl+P` 可以截图，或者修改代码使用 `vis.capture_screen_image()`。

## 相关文件

- `lib/yolo_and_sam.py`: 合并可视化实现
- `lib/mask2pose.py`: 3D可视化实现
- `main.py`: 窗口显示控制
- `result/`: 所有可视化输出目录

